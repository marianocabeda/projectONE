// Utilitario avanzado para manejar JSON Web Tokens en el cliente con refresh autom√°tico.
// Exponemos `AuthToken` en `window` para uso desde scripts no-modulares.
(function () {
  'use strict';

  const globalScope = typeof window !== 'undefined' ? window : (typeof globalThis !== 'undefined' ? globalThis : {});
  const nativeFetch = globalScope.fetch ? globalScope.fetch.bind(globalScope) : null;

  if (!nativeFetch) {
    throw new Error('Fetch API no est√° disponible en este entorno. AuthToken requiere fetch para funcionar.');
  }

  // Usar configuraci√≥n centralizada
  const getUrl = window.AppConfig?.getUrl || ((endpoint) => {
    const API_BASE_URL = window.AppConfig?.API_BASE_URL;
    if (endpoint.startsWith('http')) return endpoint;
    if (endpoint.startsWith('/')) return API_BASE_URL + endpoint;
    return endpoint;
  });

  const getConfig = () => ({
    token: {
      refreshBufferSeconds: window.AppConfig?.token?.refreshBufferSeconds || 300,
      storageKey: window.AppConfig?.token?.storageKey || 'access_token',
      userKey: window.AppConfig?.token?.userKey || 'auth_user',
    },
    routes: {
      login: window.AppConfig?.routes?.login || '/login',
      dashboard: window.AppConfig?.routes?.dashboard || '/dashboard',
    },
  });

  let isRefreshing = false;
  let refreshPromise = null; // Promise del refresh en curso
  let refreshSubscribers = [];

  // Helper: Detectar logout en progreso (por window flag o por marca en localStorage con timestamp)
  function isLogoutInProgress() {
    try {
      if (window.isLoggingOut) return true;
      if (window._suppressAuthRedirect) return true;
      const ts = parseInt(localStorage.getItem('logout_in_progress') || '0', 10);
      if (ts && !Number.isNaN(ts)) {
        // Considerar logout v√°lido por 5 segundos
        if (Date.now() - ts < 5000) return true;
      }
    } catch (e) {
      // ignore
    }
    return false;
  }

  // ==================== GESTI√ìN DE TOKENS ====================

  // üîí SEGURIDAD: Token en memoria - NO en localStorage (inmune a XSS)
  let accessTokenMemory = null;
  let tokenExpirationTime = null;

  function saveToken(token) {
    try {
      // ‚úÖ SEGURIDAD: Guardar en MEMORIA (principal)
      accessTokenMemory = token;

      // ‚úÖ RESPALDO: Guardar en localStorage para persistir entre sesiones del navegador
      // localStorage es necesario para que la sesi√≥n persista cuando se cierra y reabre el navegador
      // Aunque es menos seguro que sessionStorage, es necesario para la funcionalidad
      try {
        const config = getConfig();
        localStorage.setItem(config.token.storageKey, token);
      } catch (e) {
        console.warn('No se pudo guardar en localStorage:', e);
      }

      const payload = parseToken(token);

      if (payload) {
        // Guardar tiempo de expiraci√≥n
        if (payload.exp) {
          tokenExpirationTime = payload.exp * 1000; // Convertir a milisegundos
        }

        // Guardar datos del usuario del payload
        const user = payload.user || {
          id: payload.sub || payload.user_id || payload.id_usuario,
          email: payload.email,
          rol: payload.rol || payload.role || payload.roles?.[0],
          nombre: payload.nombre || payload.name
        };

        try {
          const config = getConfig();
          // Guardar datos del usuario en localStorage
          localStorage.setItem(config.token.userKey, JSON.stringify(user));
        } catch (e) {
          console.error('Error guardando usuario:', e);
        }
      }

      console.log('‚úÖ Token guardado en MEMORIA + sessionStorage (seguro)');
    } catch (e) {
      console.error('Error en saveToken:', e);
    }
  }

  function getToken() {
    // ‚úÖ Prioridad 1: Leer de memoria (m√°s r√°pido)
    if (accessTokenMemory) {
      return accessTokenMemory;
    }

    // ‚úÖ Prioridad 2: Recuperar de localStorage (persiste entre sesiones)
    try {
      const config = getConfig();
      const localToken = localStorage.getItem(config.token.storageKey);
      if (localToken) {
        // Restaurar en memoria
        accessTokenMemory = localToken;
        
        // Actualizar tiempo de expiraci√≥n
        const payload = parseToken(localToken);
        if (payload && payload.exp) {
          tokenExpirationTime = payload.exp * 1000;
        }
        
        return localToken;
      }
    } catch (e) {
      // Ignorar errores de localStorage
    }

    // ‚úÖ Prioridad 3: Recuperar de sessionStorage (compatibilidad con versiones anteriores)
    try {
      const config = getConfig();
      const sessionToken = sessionStorage.getItem(config.token.storageKey);
      if (sessionToken) {
        // Restaurar en memoria
        accessTokenMemory = sessionToken;
        
        // Actualizar tiempo de expiraci√≥n
        const payload = parseToken(sessionToken);
        if (payload && payload.exp) {
          tokenExpirationTime = payload.exp * 1000;
        }
        
        return sessionToken;
      }
    } catch (e) {
      // Ignorar errores de sessionStorage
    }

    // ‚ùå No hay token disponible
    return null;
  }

  function removeToken() {
    try {
      // ‚úÖ Limpiar token de memoria
      accessTokenMemory = null;
      tokenExpirationTime = null;

      // Limpiar localStorage
      const config = getConfig();
      localStorage.removeItem(config.token.storageKey);
      
      // Limpiar sessionStorage (compatibilidad)
      sessionStorage.removeItem(config.token.storageKey);
      
      // Limpiar datos de usuario de localStorage
      localStorage.removeItem(config.token.storageKey); // Por si hab√≠a tokens antiguos
      localStorage.removeItem(config.token.userKey);
      
      // Limpiar todo sessionStorage
      sessionStorage.clear();

      console.log('‚úÖ Token limpiado de memoria y storage');
    } catch (_) { }
  }

  /**
   * Alias para compatibilidad con logout.js
   */
  function clearToken() {
    removeToken();
  }

  function getUser() {
    try {
      const config = getConfig();
      const raw = localStorage.getItem(config.token.userKey);
      return raw ? JSON.parse(raw) : null;
    } catch (_) {
      return null;
    }
  }

  function getAuthHeader() {
    const t = getToken();
    return t ? { Authorization: 'Bearer ' + t } : {};
  }

  function parseToken(token) {
    try {
      if (!token) return null;
      const parts = token.split('.');
      if (parts.length < 2) return null;
      // Adaptamos base64 URL a base64 est√°ndar
      const payloadB64 = parts[1].replace(/-/g, '+').replace(/_/g, '/');
      // Decodificar manejando caracteres UTF-8
      const json = decodeURIComponent(
        Array.prototype.map
          .call(atob(payloadB64), function (c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
          })
          .join('')
      );
      return JSON.parse(json);
    } catch (e) {
      // Error parseando token; puede estar malformado o corrupto (no mostrar error cr√≠tico)
      return null;
    }
  }

  function isExpired(token) {
    // Si tenemos el tiempo de expiraci√≥n en memoria, usarlo (m√°s eficiente)
    if (tokenExpirationTime) {
      return Date.now() > tokenExpirationTime;
    }

    // Fallback: parsear token
    const p = parseToken(token || getToken());
    if (!p) return true;
    if (typeof p.exp === 'number') {
      // exp est√° en segundos desde epoch
      return Date.now() / 1000 > p.exp;
    }
    return false;
  }

  function needsRefresh(token) {
    const config = getConfig();
    const p = parseToken(token || getToken());
    if (!p || !p.exp) return false;
    // Verificar si expira en menos de REFRESH_BUFFER_SECONDS
    const timeToExpire = p.exp - (Date.now() / 1000);
    return timeToExpire > 0 && timeToExpire < config.token.refreshBufferSeconds;
  }

  // ==================== REFRESH TOKEN ====================

  /**
   * Helper para detectar cookies duplicadas
   * Las cookies duplicadas ocurren cuando tienen diferentes atributos (Path, Domain, SameSite)
   */
  function detectDuplicateCookies() {
    const cookies = document.cookie.split(';').map(c => c.trim());
    const cookieNames = {};

    cookies.forEach(cookie => {
      const [name] = cookie.split('=');
      if (cookieNames[name]) {
        cookieNames[name]++;
      } else {
        cookieNames[name] = 1;
      }
    });

    const duplicates = Object.entries(cookieNames).filter(([_, count]) => count > 1);
    return duplicates.length > 0;
  }

  /**
   * Refresca el access token usando el refresh token (cookie httpOnly)
   */
  async function refreshAccessToken() {
    try {
      // üîí NO intentar refrescar si estamos en proceso de logout
      if (isLogoutInProgress()) {
        console.log('‚ö†Ô∏è Refresh token cancelado: logout en progreso');
        return null;
      }

      // Si ya hay un refresh en curso, esperar a que termine y retornar su resultado
      if (isRefreshing && refreshPromise) {
        return refreshPromise;
      }

      // Marcar que estamos refrescando y crear la promesa
      isRefreshing = true;

      refreshPromise = (async () => {
        try {
          detectDuplicateCookies();

          const refreshUrl = getUrl('refresh');

          // Obtener token actual si existe (incluso si expirado)
          const currentToken = getToken();

          const response = await nativeFetch(refreshUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
              // Enviar access token actual si est√° disponible (√∫til para validaci√≥n adicional)
              ...(currentToken && { 'Authorization': `Bearer ${currentToken}` })
            },
            credentials: 'include',
          });

          if (response.ok) {
            const data = await response.json();

            // El backend devuelve: { "data": { "token": "..." } }
            // Intentar m√∫ltiples formatos para mayor compatibilidad
            let newToken = null;

            if (data.data && data.data.token) {
              // Formato: { data: { token: "..." } }
              newToken = data.data.token;
            } else if (data.token) {
              // Formato directo: { token: "..." }
              newToken = data.token;
            } else if (data.accessToken) {
              // Formato alternativo: { accessToken: "..." }
              newToken = data.accessToken;
            } else if (data.access_token) {
              // Formato snake_case: { access_token: "..." }
              newToken = data.access_token;
            }

            if (newToken) {
              saveToken(newToken);
              onTokenRefreshed(newToken);
              return newToken;
            } else {
              console.error('No se encontr√≥ token en la respuesta del refresh');
              return null;
            }
          } else {
            // Si el servidor responde 401 expl√≠citamente, el refresh token es inv√°lido/expirado/revocado
            if (response.status === 401) {
              // Mostrar modal de sesi√≥n expirada si est√° disponible
              if (window.SessionExpiredModal && typeof window.SessionExpiredModal.show === 'function') {
                setTimeout(() => {
                  if (!window.SessionExpiredModal.isVisible()) {
                    window.SessionExpiredModal.show();
                  }
                }, 100);
              }
            }

            return null;
          }
        } finally {
          // Limpiar estado de refresh
          isRefreshing = false;
          refreshPromise = null;
        }
      })();

      return refreshPromise;

    } catch (error) {
      // Limpiar estado
      isRefreshing = false;
      refreshPromise = null;

      // Delegar a ErrorHandler si est√° disponible
      if (window.ErrorHandler && !isLogoutInProgress()) {
        try {
          window.ErrorHandler.handleHTTPError(error, 'login', false);
        } catch (e) {
          console.error('Error en ErrorHandler:', e);
        }
      }

      // Solo limpiar tokens si NO estamos en logout
      if (!isLogoutInProgress()) {
        removeToken();
      }
      return null;
    }
  }

  // Manejar m√∫ltiples requests mientras se refresca el token
  function subscribeTokenRefresh(callback) {
    refreshSubscribers.push(callback);
  }

  function onTokenRefreshed(token) {
    refreshSubscribers.forEach(callback => callback(token));
    refreshSubscribers = [];
  }

  // ==================== FETCH WRAPPER CON AUTO-REFRESH ====================

  async function authenticatedFetch(url, options = {}) {
    // MODO DESARROLLO: Fetch sin autenticaci√≥n
    if (window.ENV && window.ENV.isDevelopment) {
      // Hacer fetch normal sin headers de autenticaci√≥n
      const fetchOptions = {
        ...options,
        credentials: options.credentials || 'include',
      };

      return nativeFetch(url, fetchOptions);
    }

    // STAGING/PRODUCTION: Fetch con autenticaci√≥n
    // NO realizar peticiones autenticadas si estamos en logout
    if (isLogoutInProgress()) {
      throw new Error('Logout en progreso');
    }

    let token = getToken();

    // ‚ùå ELIMINADO: Chequeo proactivo de expiraci√≥n
    // El frontend ahora es REACTIVO: espera a que el backend devuelva 401
    // if (token && isExpired(token)) { ... }
    // ‚ùå ELIMINADO: Refresh en background (causaba refresh inmediato despu√©s de login)
    // El refresh solo debe ocurrir cuando el token REALMENTE expira

    // Si no hay token despu√©s de intentar refrescar, retornar error
    if (!token) {
      const config = getConfig();
      // Limpiar tokens porque ya no son v√°lidos
      if (!isLogoutInProgress()) {
        removeToken();
      }
      // Redirigir a login si no estamos ya ah√≠ y si NO estamos en logout
      if (!window.location.pathname.includes('/login.html') && !isLogoutInProgress()) {
        window.location.href = config.routes.login + '?status=error&msg=' +
          encodeURIComponent('Sesi√≥n expirada. Por favor, inicia sesi√≥n nuevamente.');
      }
      throw new Error('No hay token de autenticaci√≥n');
    }

    // Agregar headers de autenticaci√≥n
    const headers = {
      ...options.headers,
      'Authorization': `Bearer ${token}`,
    };

    // Preparar body: si es un objeto (no FormData/Blob/string), convertir a JSON
    let body = options.body;
    if (body && typeof body === 'object' && !(body instanceof FormData) && !(body instanceof Blob) && typeof body !== 'string') {
      try {
        body = JSON.stringify(body);
      } catch (e) {
        console.warn('Error al serializar body:', e);
      }
    }

    // Agregar credentials: 'include' si no est√° especificado
    const fetchOptions = {
      ...options,
      headers,
      body,
      credentials: options.credentials || 'include',
    };

    const response = await nativeFetch(url, fetchOptions);

    // Si recibimos 401, intentar refrescar una vez m√°s (solo si NO estamos en logout)
    if (response.status === 401 && !options._retry && !isLogoutInProgress()) {
      const newToken = await refreshAccessToken();
      if (newToken) {
        // Reintentar con el nuevo token
        return authenticatedFetch(url, { ...options, _retry: true });
      } else {
        // Mostrar modal de sesi√≥n expirada
        if (window.SessionExpiredModal && typeof window.SessionExpiredModal.show === 'function') {
          if (!window.SessionExpiredModal.isVisible()) {
            window.SessionExpiredModal.show();
          }
          // No redirigir autom√°ticamente - dejar que el usuario decida
          throw new Error('Sesi√≥n expirada - esperando acci√≥n del usuario');
        } else {
          // Fallback si no hay modal: redirigir a login
          const config = getConfig();
          if (!isLogoutInProgress()) {
            removeToken();
          }
          if (!window.location.pathname.includes('/login.html') && !isLogoutInProgress()) {
            window.location.href = config.routes.login + '?status=error&msg=' +
              encodeURIComponent('Sesi√≥n expirada. Por favor, inicia sesi√≥n nuevamente.');
          }
          throw new Error('No autenticado');
        }
      }
    }

    return response;
  }

  // ==================== LOGOUT ====================

  async function logout() {
    try {
      // üîç PASO 0: Verificar si el token est√° expirado y refrescarlo ANTES de marcar logout
      // Esto es crucial para que el logout pueda revocar correctamente la sesi√≥n en el backend
      let accessToken = getToken();
      
      if (accessToken && isExpired(accessToken)) {
        console.log('‚ö†Ô∏è Access token expirado, intentando refresh ANTES del logout...');
        
        try {
          const newToken = await refreshAccessToken();
          if (newToken) {
            console.log('‚úÖ Token refrescado exitosamente antes del logout');
            accessToken = newToken;
          } else {
            console.warn('‚ö†Ô∏è No se pudo refrescar el token, intentando logout con token expirado');
          }
        } catch (refreshError) {
          console.warn('‚ö†Ô∏è Error al refrescar token antes de logout:', refreshError);
          console.log('‚ÑπÔ∏è Continuando con logout usando token expirado');
        }
      } else if (accessToken) {
        console.log('‚úÖ Access token v√°lido, procediendo con logout');
      } else {
        console.log('‚ÑπÔ∏è No hay access token, procediendo con logout solo con refresh token');
      }
      
      // üîí AHORA S√ç marcar que estamos en proceso de logout
      window.isLoggingOut = true;

      const logoutUrl = getUrl('logout');

      console.log('üîì AuthToken.logout() - URL:', logoutUrl);
      console.log('üìù Access Token presente:', !!accessToken);

      // Construir headers
      const headers = {
        'Content-Type': 'application/json',
      };

      // Enviar access token en Authorization header si est√° disponible
      if (accessToken) {
        headers['Authorization'] = `Bearer ${accessToken}`;
      }

      console.log('üîë Access Token:', accessToken ? 'Presente' : 'Ausente');
      console.log('üç™ Credentials include habilitado - Refresh token (cookie httpOnly) se enviar√° autom√°ticamente');

      // El refresh token se env√≠a autom√°ticamente v√≠a cookie httpOnly
      // NO lo enviamos en el body - el backend lo lee de la cookie

      // Llamar al endpoint de logout para invalidar refresh token (cookie httpOnly)
      // credentials: 'include' env√≠a las cookies httpOnly autom√°ticamente
      const response = await nativeFetch(logoutUrl, {
        method: 'POST',
        credentials: 'include', // üî• CR√çTICO: env√≠a las cookies httpOnly al servidor
        headers: headers,
      });

      if (response.ok) {
        console.log('‚úÖ Logout exitoso en servidor - Refresh token revocado');
        const data = await response.json().catch(() => null);
        console.log('üì¶ Respuesta del servidor:', data);
      } else {
        console.warn('‚ö†Ô∏è Logout fall√≥ en servidor, status:', response.status);
        const text = await response.text().catch(() => '');
        console.warn('üìÑ Respuesta:', text);
      }
    } catch (error) {
      console.error('‚ùå Error en logout:', error);
    } finally {
      const config = getConfig();

      // üßπ Limpieza EXHAUSTIVA de todos los storages
      console.log('üßπ Limpiando storage local...');

      // Limpiar memoria
      accessTokenMemory = null;
      tokenExpirationTime = null;

      // Limpiar localStorage (solo datos de usuario, ya no hay tokens)
      localStorage.setItem('logout_complete', Date.now().toString()); // Marca de tiempo para evitar auto-restore inmediato
      const tokenKey = config.token.storageKey;
      const userKey = config.token.userKey;
      localStorage.removeItem(tokenKey); // Por si hab√≠a tokens antiguos
      localStorage.removeItem(userKey);
      localStorage.removeItem('access_token'); // Legacy cleanup
      localStorage.removeItem('refresh_token'); // Legacy cleanup
      localStorage.removeItem('auth_user'); // Legacy cleanup

      // Limpiar sessionStorage
      sessionStorage.clear();

      // Las cookies httpOnly son limpiadas por el backend
      // Solo limpiamos cookies NO httpOnly que pudieran existir
      document.cookie = 'access_token=; Max-Age=0; path=/; SameSite=Lax';
      document.cookie = 'access_token=; Max-Age=0; path=/; domain=' + window.location.hostname + '; SameSite=Lax';

      console.log('‚úÖ Limpieza completa finalizada');
      console.log('‚ÑπÔ∏è Las cookies httpOnly (refresh_token) fueron limpiadas por el backend');

      // üîÑ Redirigir al login y recargar
      console.log('üîÑ Redirigiendo a login...');
      window.location.href = config.routes.login;

      // Fallback: forzar reload si la redirecci√≥n no funciona
      setTimeout(() => {
        window.location.reload();
      }, 100);
    }
  }

  // ==================== VERIFICAR AUTENTICACI√ìN ====================

  function isAuthenticated() {
    // MODO DESARROLLO: Siempre autenticado
    if (window.ENV && window.ENV.isDevelopment) {
      return true;
    }

    // Staging/Production: verificar token real
    const token = getToken();
    return token && !isExpired(token);
  }

  function requireAuth() {
    // MODO DESARROLLO: No requiere autenticaci√≥n
    if (window.ENV && window.ENV.isDevelopment) {
      return;
    }

    // Staging/Production: requiere autenticaci√≥n real
    if (!isAuthenticated()) {
      const config = getConfig();
      // Si estamos en proceso de logout expl√≠cito, no agregamos par√°metros de error
      if (isLogoutInProgress()) {
        window.location.href = config.routes.login;
      } else {
        window.location.href = config.routes.login + '?status=error&msg=' +
          encodeURIComponent('Debes iniciar sesi√≥n para acceder a esta p√°gina.');
      }
    }
  }

  // ==================== GLOBAL FETCH INTERCEPTOR ====================

  function headersToObject(headers = {}) {
    if (headers instanceof Headers) {
      const converted = {};
      headers.forEach((value, key) => {
        converted[key] = value;
      });
      return converted;
    }

    if (Array.isArray(headers)) {
      return headers.reduce((acc, [key, value]) => {
        if (key) acc[key] = value;
        return acc;
      }, {});
    }

    return { ...headers };
  }

  function shouldInterceptFetch(url, options = {}) {
    if (!url || options._skipAuth === true || options._forceNativeFetch === true) {
      return false;
    }

    if (options._useAuthToken === true) {
      return true;
    }

    if (typeof url !== 'string') {
      return false;
    }

    const lowerUrl = url.toLowerCase();
    // Construir din√°micamente las rutas que deben bypassear el interceptor.
    // Preferimos resolverlas desde AppConfig para evitar hardcodear rutas.
    const getUrlFn = window.AppConfig?.getUrl || ((e) => e);

    const dynamicEndpoints = [
      'login',
      'register',
      'refresh',
      'logout',
      'forgotPassword',
      'resetPassword',
      'resendVerification',
      'verifyEmail'
    ];

    const bypassSegments = (function() {
      try {
        if (window.AppConfig && window.AppConfig.endpoints) {
          // Resolver cada clave a su URL (si existe) y a√±adir su path y lowercased forms
          const segments = new Set();
          dynamicEndpoints.forEach(key => {
            const resolved = getUrlFn(key) || window.AppConfig.endpoints[key];
            if (!resolved) return;
            const urlStr = String(resolved).toLowerCase();
            // A√±adir la ruta tal como viene (puede ser '/api/..' o '/auth/..')
            segments.add(urlStr);
            // Tambi√©n agregar solo la porci√≥n de ruta si la URL es absoluta
            try {
              const u = new URL(resolved, window.location.origin);
              segments.add(u.pathname.toLowerCase());
            } catch (e) {
              // ignore
            }
          });
          // A√±adir legacy fallback patterns for compatibility
          ['/v1/auth/login','/auth/login','/v1/registro','/auth/register','/v1/auth/refresh','/auth/refresh','/v1/api/auth/logout','/auth/logout','/v1/auth/solicitar-cambio-password','/auth/forgot-password','/v1/auth/cambiar-password','/auth/reset-password','/v1/auth/reenvio-email-verificacion','/auth/reenvio-email-verificacion','/v1/auth/verificar-email','/auth/verify-email'].forEach(p => segments.add(p));
          return Array.from(segments);
        }
      } catch (e) {
        // ignore and fallback to static list
      }

      // Fallback hardcoded list (legacy)
      return [
        '/v1/auth/login',
        '/auth/login',
        '/v1/registro',
        '/auth/register',
        '/v1/auth/refresh',
        '/auth/refresh',
        '/v1/api/auth/logout',
        '/auth/logout',
        '/v1/auth/solicitar-cambio-password',
        '/auth/forgot-password',
        '/v1/auth/cambiar-password',
        '/auth/reset-password',
        '/v1/auth/reenvio-email-verificacion',
        '/auth/reenvio-email-verificacion',
        '/v1/auth/verificar-email',
        '/auth/verify-email'
      ];
    })();

    if (bypassSegments.some(segment => lowerUrl.includes(segment))) {
      return false;
    }

    const headers = headersToObject(options.headers);
    const authHeader = headers.Authorization || headers.authorization;
    if (authHeader && authHeader.toLowerCase().startsWith('bearer ')) {
      return true;
    }

    return false;
  }

  function setupGlobalFetchInterceptor() {
    if (!nativeFetch || globalScope.__authFetchPatched) {
      return;
    }

    globalScope.__authFetchPatched = true;
    globalScope.__nativeFetch = nativeFetch;

    globalScope.fetch = function patchedFetch(input, init = {}) {
      if (typeof input !== 'string') {
        return nativeFetch(input, init);
      }

      const options = init || {};
      if (shouldInterceptFetch(input, options)) {
        const normalizedOptions = { ...options };
        normalizedOptions.headers = headersToObject(options.headers);
        return authenticatedFetch(input, normalizedOptions);
      }

      return nativeFetch(input, options);
    };
  }

  // Activar interceptor global inmediatamente (idempotente)
  setupGlobalFetchInterceptor();

  // ==================== EXPORTAR API ====================

  window.AuthToken = {
    // Gesti√≥n b√°sica de tokens
    saveToken,
    getToken,
    removeToken,
    clearToken, // Alias para compatibilidad
    getAuthHeader,
    parseToken,
    isExpired,
    getUser,

    // Nuevas funcionalidades
    needsRefresh,
    refreshAccessToken,
    authenticatedFetch,
    // Helper para que otros m√≥dulos verifiquen si hay un logout en progreso
    isLogoutInProgress,
    logout,
    isAuthenticated,
    requireAuth,
    attachFetchInterceptor: setupGlobalFetchInterceptor,
  };
})();
